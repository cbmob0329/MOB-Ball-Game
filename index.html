<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no">
<title>MOB 3on3 Dodgeball – Square 512 (pickup+roles)</title>
<style>
  :root{ --ui:#0d0f12; --card:#1b1f27; --card2:#2b303b; }
  html,body{margin:0;height:100%;background:#000;color:#fff;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Sans","Yu Gothic",sans-serif}
  #wrap{position:fixed;inset:0;display:flex;flex-direction:column}
  #hudTop{flex:0 0 auto;display:flex;gap:8px;align-items:center;padding:8px 10px;background:var(--ui);font-size:14px}
  .pill{background:#161a22;padding:6px 10px;border-radius:999px}
  #stage{flex:1 1 auto;display:flex;justify-content:center;align-items:center;background:#000}
  #cv{width:min(100vmin,100vw);height:min(100vmin,calc(100vh - 220px));display:block;image-rendering:pixelated;touch-action:none}
  #hudBtm{flex:0 0 auto;display:flex;align-items:center;justify-content:space-between;padding:10px;background:var(--ui);gap:8px}

  /* Virtual joystick (small) */
  .joy{position:relative;width:120px;height:120px}
  .joy .base{position:absolute;inset:0;border-radius:50%;background:#111;box-shadow:inset 0 0 0 2px #2b303b}
  .joy .ring{position:absolute;inset:12px;border-radius:50%;border:2px dashed #3d4557;opacity:.7}
  .joy .knob{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:54px;height:54px;border-radius:50%;background:#1b1f27;box-shadow:0 0 0 2px #4d5566 inset}
  .actions{display:flex;gap:10px}
  .ab{width:90px;height:90px;border-radius:14px;background:#1b1f27;box-shadow:inset 0 0 0 2px #2b303b;display:flex;flex-direction:column;align-items:center;justify-content:center}
  .ab small{opacity:.7}

  #toast{position:fixed;left:50%;transform:translateX(-50%);bottom:calc(env(safe-area-inset-bottom,0px) + 10px);background:#000a;padding:8px 12px;border-radius:10px;font-size:12px;pointer-events:none;opacity:0;transition:opacity .2s}

  /* 頭上メニュー（小さな長方形） */
  .btnRow{position:absolute;display:flex;gap:4px;padding:4px;background:#000a;border:1px solid #fff4;border-radius:6px}
  .btnRow button{font:12px/1.2 monospace;color:#000;border:none;border-radius:4px;padding:4px 6px;min-width:40px;cursor:pointer}
  .bTech{background:#6ab0ff}.bPower{background:#ffc24a}.bSp{background:#fff}.bSp[disabled]{background:#777;color:#333;cursor:not-allowed}
</style>
</head>
<body>
<div id="wrap">
  <div id="hudTop">
    <div class="pill">MVP（512）</div>
    <div class="pill">時間: <span id="time">120</span>s</div>
    <div class="pill">必殺: <span id="sp">2</span></div>
    <div class="pill">操作：敵タップ→頭上メニュー→自分頭上ゲージをタップで止める</div>
  </div>

  <div id="stage" style="position:relative">
    <canvas id="cv" width="512" height="512"></canvas>
    <div id="headMenu" class="btnRow" style="display:none">
      <button class="bTech"  data-choice="tech">テク</button>
      <button class="bPower" data-choice="power">パワ</button>
      <button class="bSp"    data-choice="sp">必殺</button>
    </div>
  </div>

  <div id="hudBtm">
    <div class="joy" id="joy">
      <div class="base"></div><div class="ring"></div><div class="knob" id="knob"></div>
    </div>
    <div class="actions">
      <div class="ab" id="btnCatch"><div>CATCH</div><small>近距離</small></div>
      <div class="ab" id="btnCancel"><div>キャンセル</div><small>解除</small></div>
    </div>
  </div>
</div>
<div id="toast"></div>

<script>
(() => {
  // ===== Canvas =====
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d'); ctx.imageSmoothingEnabled = false;

  // ===== HUD refs =====
  const timeEl = document.getElementById('time');
  const spEl   = document.getElementById('sp');
  const toast  = document.getElementById('toast');

  // ===== DOM menu =====
  const headMenu = document.getElementById('headMenu');
  const btnTech  = headMenu.querySelector('[data-choice="tech"]');
  const btnPower = headMenu.querySelector('[data-choice="power"]');
  const btnSp    = headMenu.querySelector('[data-choice="sp"]');

  // ===== Images =====
  const imgBG = new Image(); imgBG.src = 'DMH.png';
  const imgBall = new Image(); imgBall.src = 'ball.png';
  const imgChar = new Image(); imgChar.src = 'DMY1.png';

  // ===== Const =====
  const centerX=256, gTop=80, gBot=480, lB=32, rB=480;
  const courtW=512, courtH=512;

  const coeff = {
    techSpeed: 7.0, powerSpeed: 10.8, specialSpeed: 12.5,
    techCost: 12, powerCost: 24,
    catchWindowMs: 110,
    recoverPerSec: 3,
    knockTech:[8,14], knockPower:[18,26], knockSpcl:[28,40],
    gaugeTime: 680,         // 片道（往復表示）
    pickupDelayMs: 60,      // ★転がり回収遅延（短縮）
    pickupDist: 28          // ★転がり回収距離（拡大）
  };

  // ===== Util =====
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const rand=(a,b)=>a+Math.random()*(b-a);
  const now=()=>performance.now();
  const pingpong=(t)=>{ t%=2; return t<1?t:2-t; };

  // ===== Entities =====
  class Player{
    constructor(side,x,y,isHuman=false,role='front',lane='mid'){
      this.side=side; this.x=x; this.y=y; this.w=32; this.h=32; this.isHuman=isHuman;
      this.role=role;   // 'front' | 'back'
      this.lane=lane;   // 'top' | 'mid' | 'bot'
      this.stats={Power:62,Tech:58,Speed:82,Stamina:70,Catch:55,HP:112,Focus:55,Stability:50};
      this.speed = 2.1 + this.stats.Speed*0.013;
      this.maxHP=this.stats.HP; this.hp=this.maxHP;
      this.staminaMax=100+this.stats.Stamina*0.5;
      this.stamina=this.staminaMax; this.staRegen=coeff.recoverPerSec+this.stats.Stamina*0.03;
      this.catchBonusMs = coeff.catchWindowMs + this.stats.Catch*0.3 + this.stats.Focus*0.2 + 40;
      this.dead=false; this.fade=1; this.hurt=0; this.cool=0;
      this.target=null; this.specialLeft=2; this.aiNext=now()+rand(120,220);
      this.vx=0; this.vy=0;
    }
    rect(){ return {x:this.x-16,y:this.y-28,w:this.w,h:this.h}; }
  }
  class Ball{
    constructor(){ this.x=centerX; this.y=(gTop+gBot)/2; this.vx=0; this.vy=0; this.owner=null; this.state='free'; this.lastThrow=0; this.lastChoice='power'; }
  }

  // ===== Team build: 1前衛+2後衛（上/下レーン） =====
  const L=[
    new Player('L', lB+84, 200, true,  'front','mid'), // human front
    new Player('L', lB+60, 150, false, 'back','top'),
    new Player('L', lB+60, 300, false, 'back','bot'),
  ];
  const R=[
    new Player('R', rB-84, 200, false, 'front','mid'),
    new Player('R', rB-60, 150, false, 'back','top'),
    new Player('R', rB-60, 300, false, 'back','bot'),
  ];
  const ALL=[...L,...R]; const human=L[0]; const ball=new Ball();

  // ===== State =====
  let last=now(), paused=false, timeLeft=120000, extendTime=30000;
  let selectedEnemy=null;
  let gauge=null; // {who,target,choice,t0,done,tap}
  let aiGauge=null; // {who,t0,dur,choice}
  let catchHint=null; // {who,until}
  let blinkT=0;

  // ===== Joystick =====
  const joy = document.getElementById('joy');
  const knob= document.getElementById('knob');
  let joyActive=false, joyVec={x:0,y:0};
  const joyRect=()=>joy.getBoundingClientRect();
  function joySet(e,on){ joyActive=on; if(!on){ joyVec={x:0,y:0}; knob.style.left='50%'; knob.style.top='50%'; return; } joyMove(e); }
  function joyMove(e){
    const r=joyRect(), cx=r.left+r.width/2, cy=r.top+r.height/2;
    const tx=(e.touches?e.touches[0].clientX:e.clientX), ty=(e.touches?e.touches[0].clientY:e.clientY);
    let dx=tx-cx, dy=ty-cy; const len=Math.hypot(dx,dy)||1, maxR=44;
    if(len>maxR){ dx=dx/len*maxR; dy=dy/len*maxR; }
    knob.style.left=(50 + dx/(r.width/2)*50)+'%'; knob.style.top=(50 + dy/(r.height/2)*50)+'%';
    joyVec={x:dx/maxR, y:dy/maxR};
  }
  joy.addEventListener('mousedown',e=>joySet(e,true));
  window.addEventListener('mouseup',()=>joySet(null,false));
  joy.addEventListener('mousemove',e=>{ if(joyActive) joyMove(e); });
  joy.addEventListener('touchstart',e=>{ joySet(e,true); },{passive:true});
  joy.addEventListener('touchend',()=>joySet(null,false),{passive:true});
  joy.addEventListener('touchmove',e=>{ if(joyActive) joyMove(e); },{passive:true});

  // ===== Buttons =====
  document.getElementById('btnCancel').onclick=()=>{ closeMenu(); selectedEnemy=null; human.target=null; gauge=null; };
  document.getElementById('btnCatch').onclick=()=>{
    // free（転がり）も回収OK
    if(ball.state==='free' && dist(human.x,human.y,ball.x,ball.y) < coeff.pickupDist+8){
      pickupBall(human); return;
    }
    if(canAttemptCatch(human)) tryCatch(human);
  };

  // ===== Menu events =====
  for(const el of [btnTech,btnPower,btnSp]){
    el.addEventListener('click', ()=>{
      if(!selectedEnemy) return;
      const ch=el.dataset.choice;
      if(ch==='sp' && human.specialLeft<=0){ toastMsg('必殺なし'); return; }
      startGauge(human, selectedEnemy, ch);
      closeMenu();
    });
  }

  // ===== Canvas taps =====
  cv.addEventListener('pointerdown',(e)=>{
    const r=cv.getBoundingClientRect();
    const x=(e.clientX-r.left)/(r.width/cv.width);
    const y=(e.clientY-r.top)/(r.height/cv.height);

    // ゲージ停止（往復）
    if(gauge && !gauge.done){ gauge.tap=now(); gauge.done=true; return; }

    // 敵選択
    const hit = pickEnemyAt(x,y,R);
    if(hit){
      selectedEnemy=hit; human.target=hit; openMenuAbove(hit); return;
    }
    // フィールドタップ → メニュー閉じ
    closeMenu(); selectedEnemy=null; human.target=null;
  });

  // ===== Helpers =====
  function dist(ax,ay,bx,by){const dx=ax-bx,dy=ay-by;return Math.hypot(dx,dy);}
  function toastMsg(s){ toast.textContent=s; toast.style.opacity=1; clearTimeout(toast._t); toast._t=setTimeout(()=>toast.style.opacity=0,1200); }
  function pickEnemyAt(x,y,list){
    let best=null,bd=1e9;
    for(const p of list){
      if(p.dead) continue; const r=p.rect(); const ex=6,ey=6;
      if(x>=r.x-ex && x<=r.x+r.w+ex && y>=r.y-ey && y<=r.y+r.h+ey){ const d=Math.hypot(p.x-x,p.y-y); if(d<bd){bd=d; best=p;} }
    } return best;
  }
  function openMenuAbove(enemy){
    const stage = document.getElementById('stage').getBoundingClientRect();
    const rect=cv.getBoundingClientRect();
    const ex = (enemy.x/cv.width) * rect.width + rect.left;
    const ey = ((enemy.rect().y-10)/cv.height) * rect.height + rect.top;
    headMenu.style.left = (ex - stage.left - headMenu.offsetWidth/2) + 'px';
    headMenu.style.top  = (ey - stage.top) + 'px';
    headMenu.style.display='flex';
    btnSp.disabled = human.specialLeft<=0;
  }
  function closeMenu(){ headMenu.style.display='none'; }

  // ===== Gauge =====
  function startGauge(who,target,choice){
    if(choice==='sp'){ who.specialLeft=Math.max(0, who.specialLeft-1); spEl.textContent=human.specialLeft; }
    if(choice==='power' && who.stamina<coeff.powerCost*0.8) choice='tech';
    gauge={who,target,choice,t0:now(),done:false,tap:0};
  }
  function finishGauge(g){
    const t=(g.tap - g.t0)/coeff.gaugeTime; const perf = clamp(pingpong(t),0,1);
    doThrow(g.who, g.target, g.choice, perf); gauge=null;
  }

  // ===== Throw =====
  function doThrow(who,target,choice,perf){
    if(choice==='power') who.stamina -= coeff.powerCost*(1.0 - perf*0.3);
    if(choice==='tech')  who.stamina -= coeff.techCost*(1.0 - perf*0.5);
    who.stamina=clamp(who.stamina,0,who.staminaMax);

    const spd = (choice==='power') ? (8.5 + perf*(coeff.powerSpeed-8.5))
              : (choice==='tech')  ? (5.8 + perf*(coeff.techSpeed-5.8))
              :                      (10.5+ perf*(coeff.specialSpeed-10.5));
    const dx=target.x-who.x, dy=target.y-who.y, ang=Math.atan2(dy,dx);
    ball.x=who.x + Math.cos(ang)*18; ball.y=who.y + Math.sin(ang)*12;
    ball.vx=Math.cos(ang)*spd; ball.vy=Math.sin(ang)*(spd*0.55);
    ball.owner=who; ball.state='air'; ball.lastThrow=now(); ball.lastChoice=choice;
    who.cool=160;
  }

  // ===== Catch / Pickup =====
  function canAttemptCatch(p){
    if(p.dead) return false;
    if(ball.state!=='air') return false;
    if(!ball.owner || ball.owner===p) return false;
    const towardLeft = ball.vx<0;
    if(p.side==='L' && !towardLeft) return false;
    if(p.side==='R' && towardLeft) return false;
    return dist(p.x,p.y, ball.x,ball.y) < 72;
  }
  function tryCatch(p){
    const elapsed = now()-ball.lastThrow; const center = 520;
    const diff = Math.abs(elapsed - center);
    const ok = diff < p.catchBonusMs;
    if(ok){ pickupBall(p,true); toastMsg('キャッチ！'); }
    else { p.hurt=120; }
  }
  function pickupBall(p,fromAir=false){
    ball.owner=p; ball.state='owned'; ball.vx=ball.vy=0;
    if(fromAir){ p.stamina = clamp(p.stamina+12,0,p.staminaMax); }
  }

  // ===== Damage / Knockback =====
  function onHit(def,choice,atk){
    let dmg=(choice==='power')?rand(26,34):(choice==='tech')?rand(18,24):rand(40,55);
    dmg *= (1 + (atk.stats.Power||60)*0.004);
    let kb=(choice==='power')?rand(...coeff.knockPower):(choice==='tech')?rand(...coeff.knockTech):rand(...coeff.knockSpcl);
    kb *= (1 - (def.stats.Stability||50)*0.008); kb=clamp(kb,4,42);
    def.hp -= Math.round(dmg); def.hurt=140;
    def.vx += (atk.x<def.x?1:-1) * kb*0.09; def.vy += rand(-0.4,0.4);
    if(def.hp<=0){ def.hp=0; def.dead=true; def.fade=1; }
  }

  // ===== Bounds & Move =====
  function clampSide(p){
    if(p.side==='L') p.x=clamp(p.x,lB+16,centerX-16); else p.x=clamp(p.x,centerX+16,rB-16);
    p.y=clamp(p.y,gTop+16,gBot-8);
  }
  function moveToward(p,tx,ty,ratio){
    const dx=tx-p.x, dy=ty-p.y, len=Math.hypot(dx,dy)||1, sp=p.speed*ratio;
    p.x += dx/len*sp; p.y += dy/len*sp; clampSide(p);
  }

  // ===== Roles & Formations =====
  function laneY(lane){
    if(lane==='top') return 150;
    if(lane==='bot') return 300;
    return 220; // mid
  }
  function desiredPos(p){
    // 状況判定
    const oppOwns = ball.owner && ball.owner.side!==p.side;
    const ballOnOppHalf = (ball.x > centerX && p.side==='L') || (ball.x < centerX && p.side==='R');

    // 基準x
    let baseFront = (p.side==='L') ? centerX-44 : centerX+44;   // 前衛の基準
    let baseBack  = (p.side==='L') ? lB+52     : rB-52;         // 後衛の基準

    // 徹底して下がる条件
    if(oppOwns || ballOnOppHalf){
      baseFront = (p.side==='L')? centerX-80 : centerX+80;
      baseBack  = (p.side==='L')? lB+40      : rB-40;
    } else {
      // 味方優勢（前に出る）
      baseFront = (p.side==='L')? centerX-44 : centerX+44;
      baseBack  = (p.side==='L')? lB+70      : rB-70;
    }

    const x = (p.role==='front') ? baseFront : baseBack;
    const y = laneY(p.lane);
    return {x,y};
  }
  function applySeparation(team){
    // 最低28px離す
    const minD=28;
    for(let i=0;i<team.length;i++){
      for(let j=i+1;j<team.length;j++){
        const a=team[i], b=team[j];
        if(a.dead||b.dead) continue;
        let dx=a.x-b.x, dy=a.y-b.y, d=Math.hypot(dx,dy);
        if(d>0 && d<minD){
          const push=(minD-d)/2; dx/=d; dy/=d;
          a.x += dx*push; a.y += dy*push;
          b.x -= dx*push; b.y -= dy*push;
          clampSide(a); clampSide(b);
        }
      }
    }
  }

  // ===== Game loop =====
  function step(ms){
    if(paused) return;
    timeLeft -= ms; if(timeLeft<=0){
      const La=L.filter(p=>!p.dead).length, Ra=R.filter(p=>!p.dead).length;
      if(La===Ra && extendTime>0){ timeLeft+=extendTime; extendTime=0; } else return endMatch(La>Ra?'勝ち':(La<Ra?'負け':'引き分け'));
    }
    timeEl.textContent = Math.ceil(timeLeft/1000);

    // Human move
    if(!human.dead){
      const len=Math.hypot(joyVec.x,joyVec.y)||1;
      human.x += (joyVec.x/len)*human.speed; human.y += (joyVec.y/len)*human.speed; clampSide(human);
    }

    // Regen / timers
    for(const p of ALL){
      if(p.dead){ p.fade=Math.max(0,p.fade-ms*0.002); continue; }
      p.stamina = clamp(p.stamina + p.staRegen*(ms/1000), 0, p.staminaMax);
      if(p.hurt>0) p.hurt-=ms;
      if(p.cool>0) p.cool-=ms;
    }

    // Human gauge
    if(gauge && gauge.done) finishGauge(gauge);

    // CPU think（頻度高め）
    const tnow=now();
    for(const p of [...L,...R]){
      if(p.isHuman||p.dead) continue;
      if(p.aiNext<=tnow){ cpuThink(p); p.aiNext=tnow+rand(100,180); }
    }

    // Ball physics
    if(ball.state==='air'){
      ball.x+=ball.vx; ball.y+=ball.vy; ball.vy*=0.995;
      if(ball.y<gTop){ ball.y=gTop; ball.vy*=-0.6; }
      if(ball.y>gBot){ ball.y=gBot; ball.vy*=-0.6; }
      if(ball.x<lB){ ball.x=lB; ball.vx*=-0.6; }
      if(ball.x>rB){ ball.x=rB; ball.vx*=-0.6; }

      if(canAttemptCatch(human)) catchHint={who:human, until:now()+480};

      // 当たり
      const enemies=(ball.owner && ball.owner.side==='L')?R:L;
      let hit=null;
      for(const e of enemies){
        if(e.dead) continue; const r=e.rect();
        if(ball.x>=r.x && ball.x<=r.x+r.w && ball.y>=r.y && ball.y<=r.y+r.h){ hit=e; break; }
      }
      if(hit){
        onHit(hit, ball.lastChoice||'power', ball.owner||hit);
        ball.state='free'; ball.owner=null; ball.vx=ball.vy=0; ball.lastThrow=now();
      }
    }else if(ball.state==='free'){
      // 転がり → 近い人がすぐ拾えるように
      ball.vx*=0.98; ball.vy*=0.98; ball.x+=ball.vx; ball.y+=ball.vy;
      if(now()-ball.lastThrow>coeff.pickupDelayMs){
        let best=null, bd=1e9;
        for(const p of ALL){ if(p.dead) continue; const d=dist(p.x,p.y,ball.x,ball.y); if(d<bd){bd=d; best=p;} }
        if(best && bd<coeff.pickupDist){ pickupBall(best); }
      }
    }else if(ball.state==='owned'){
      if(ball.owner && !ball.owner.dead){
        const sgn=(ball.owner.side==='L')?1:-1;
        ball.x=ball.owner.x+10*sgn; ball.y=ball.owner.y-6;
      }else{ ball.state='free'; ball.owner=null; }
    }

    // Formation steering（目標地点へ＆セパレーション）
    for(const team of [L,R]){
      for(const p of team){
        if(p.isHuman||p.dead) continue;
        const {x,y}=desiredPos(p);
        // 持ってたら少し前傾
        const bias = (ball.owner===p)? 1.0 : 0.7;
        moveToward(p,x,y,bias);
      }
      applySeparation(team);
    }

    // KO
    const La=L.filter(p=>!p.dead).length, Ra=R.filter(p=>!p.dead).length;
    if(La===0 || Ra===0) endMatch(La>0?'勝ち':'負け');
  }

  // ===== CPU =====
  function cpuThink(p){
    if(p.dead) return;
    // 所持→予告ゲージ→投球（テンポUP）
    if(ball.owner===p && p.cool<=0 && !aiGauge){
      const enemies=(p.side==='L'?R:L).filter(q=>!q.dead); if(!enemies.length) return;
      enemies.sort((a,b)=>dist(p.x,p.y,a.x,a.y)-dist(p.x,p.y,b.x,b.y));
      const t=enemies[0];
      const choice = (p.stamina>24 && Math.random()<0.6) ? 'power' : 'tech';
      aiGauge = { who:p, t0:now(), dur:coeff.gaugeTime, choice };
      setTimeout(()=>{
        if(!p.dead && ball.owner===p){
          doThrow(p,t,choice,0.82);
          aiGauge=null;
        }
      }, coeff.gaugeTime*0.82);
      return;
    }
    // 近距離ならキャッチ試行
    if(ball.state==='air' && canAttemptCatch(p) && Math.random()<0.12){ tryCatch(p); }
    // 転がり回収も積極的に
    if(ball.state==='free' && dist(p.x,p.y,ball.x,ball.y)<coeff.pickupDist+6){ pickupBall(p); }
  }

  function endMatch(result){ paused=true; setTimeout(()=>alert(`試合終了：${result}\n（リロードで再戦）`),10); }

  // ===== Render =====
  function draw(){
    if(imgBG.complete && imgBG.naturalWidth>0) ctx.drawImage(imgBG,0,0,cv.width,cv.height);
    else { ctx.fillStyle='#063'; ctx.fillRect(0,0,cv.width,cv.height); }
    ctx.fillStyle="#ffffff55"; ctx.fillRect(centerX-1,gTop,2,gBot-gTop);

    const list=ALL.slice().sort((a,b)=>a.y-b.y); blinkT+=0.1;
    for(const p of list){
      const r=p.rect();
      if(!p.dead){
        const w=28,h=4,hpw=Math.round(w*(p.hp/p.maxHP));
        ctx.fillStyle="#0008"; ctx.fillRect(p.x-w/2, r.y-7, w, h);
        ctx.fillStyle="#0f0"; ctx.fillRect(p.x-w/2, r.y-7, Math.max(0,hpw), h);
      }
      ctx.save();
      if(p.hurt>0){ ctx.globalAlpha=0.6+0.4*Math.sin((p.hurt/140)*24); }
      const flip=(p.side==='R')?-1:1;
      if(imgChar.complete && imgChar.naturalWidth>0){
        ctx.translate(p.x, r.y); ctx.scale(flip,1); ctx.drawImage(imgChar, -16, 0, 32,32);
      }else{ ctx.fillStyle='#ffd60a'; ctx.fillRect(r.x,r.y,32,32); ctx.strokeStyle="#000"; ctx.strokeRect(r.x+0.5,r.y+0.5,31,31); }
      ctx.restore();

      if(p===selectedEnemy){
        const radius=14; const alpha=0.5+0.4*Math.sin(blinkT*10);
        ctx.strokeStyle=`rgba(255,0,0,${alpha.toFixed(3)})`; ctx.lineWidth=3;
        ctx.beginPath(); ctx.arc(p.x,p.y,radius,0,Math.PI*2); ctx.stroke();
      }
    }

    if(imgBall.complete && imgBall.naturalWidth>0) ctx.drawImage(imgBall, Math.round(ball.x-8), Math.round(ball.y-8), 16,16);
    else { ctx.fillStyle="#f90"; ctx.fillRect(ball.x-4,ball.y-4,8,8); }

    // human gauge
    if(gauge) drawGaugeAbove(gauge.who, gauge.choice, (now()-gauge.t0)/coeff.gaugeTime);
    // AI telegraph gauge
    if(aiGauge) drawGaugeAbove(aiGauge.who, aiGauge.choice, (now()-aiGauge.t0)/aiGauge.dur);

    if(catchHint && now()<catchHint.until){
      const p=catchHint.who; ctx.fillStyle="#000a"; ctx.fillRect(p.x-36, p.y-56, 72, 14);
      ctx.fillStyle="#fff"; ctx.font="10px monospace"; ctx.textAlign="center"; ctx.fillText("CATCH!", p.x, p.y-45);
    }
  }

  function drawGaugeAbove(who, choice, tRaw){
    const t=pingpong(tRaw); const w=150,h=12;
    const x=clamp(who.x-w/2, 20, courtW-w-20), y=who.y-46;
    ctx.fillStyle="#000a"; ctx.fillRect(x-2,y-2,w+4,h+4);
    ctx.fillStyle="#222"; ctx.fillRect(x,y,w,h);
    ctx.fillStyle="#0f0"; ctx.fillRect(x+2,y+2,Math.floor(w*0.5)-2,h-4);
    ctx.fillStyle="#ff0"; ctx.fillRect(x+Math.floor(w*0.5),y+2,Math.floor(w*0.3),h-4);
    ctx.fillStyle="#f30"; ctx.fillRect(x+Math.floor(w*0.8),y+2,Math.floor(w*0.2)-2,h-4);
    const cur=Math.floor((w-6)*t); ctx.fillStyle="#fff"; ctx.fillRect(x+3+cur,y+1,4,h-2);
    ctx.fillStyle="#fff"; ctx.font="10px monospace"; ctx.textAlign="center";
    const lab=choice==='power'?'パワー':(choice==='tech'?'テク':'必殺'); ctx.fillText(lab, x+w/2, y-6);
  }

  function loop(){ const t=now(); const ms=t-last; last=t; step(ms); draw(); requestAnimationFrame(loop); }
  loop();

  // ===== Window =====
  window.addEventListener('keydown',e=>{ if(e.key==='Escape'){ closeMenu(); selectedEnemy=null; } });

})();
</script>
</body>
</html>
