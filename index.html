<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no">
<title>MOB 3on3 Dodgeball – free-move AI + pass (tap switch / double-tap pass)</title>
<style>
  :root{ --ui:#0d0f12; --card:#1b1f27; --card2:#2b303b; }
  html,body{ margin:0; height:100%; background:#000; color:#fff;
             font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Sans","Yu Gothic",sans-serif;
             overscroll-behavior:none; }
  body{ overflow:hidden; }
  #wrap{ position:fixed; inset:0; display:flex; flex-direction:column; background:#000; }
  #hudTop{ flex:0 0 auto; display:flex; gap:8px; align-items:center; padding:8px 10px; background:var(--ui); font-size:14px }
  .pill{ background:#161a22; padding:6px 10px; border-radius:999px }
  #stage{ flex:1 1 auto; display:flex; justify-content:center; align-items:center; background:#000; position:relative; }
  #cv{ width:min(100vmin,100vw); height:min(100vmin,calc(100vh - 220px));
       display:block; image-rendering:pixelated; touch-action:none; background:#000 }
  #hudBtm{ flex:0 0 auto; display:flex; align-items:center; justify-content:space-between; padding:10px; background:var(--ui); gap:8px }

  /* Virtual joystick */
  .joy{ position:relative; width:120px; height:120px; touch-action:none }
  .joy .base{ position:absolute; inset:0; border-radius:50%; background:#111; box-shadow:inset 0 0 0 2px #2b303b }
  .joy .ring{ position:absolute; inset:12px; border-radius:50%; border:2px dashed #3d4557; opacity:.7 }
  .joy .knob{ position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:54px; height:54px; border-radius:50%;
              background:#1b1f27; box-shadow:0 0 0 2px #4d5566 inset }

  .actions{ display:flex; gap:10px }
  .ab{ width:90px; height:90px; border-radius:14px; background:#1b1f27; box-shadow:inset 0 0 0 2px #2b303b;
       display:flex; flex-direction:column; align-items:center; justify-content:center }
  .ab small{ opacity:.7 }

  #toast{ position:fixed; left:50%; transform:translateX(-50%);
          bottom:calc(env(safe-area-inset-bottom,0px) + 10px); background:#000a;
          padding:8px 12px; border-radius:10px; font-size:12px; pointer-events:none; opacity:0; transition:opacity .2s }

  /* 頭上メニュー（小さな長方形） */
  .btnRow{ position:absolute; display:flex; gap:4px; padding:4px; background:#000a; border:1px solid #fff4; border-radius:6px }
  .btnRow button{ font:12px/1.2 monospace; color:#000; border:none; border-radius:4px; padding:4px 6px; min-width:40px; cursor:pointer }
  .bTech{ background:#6ab0ff } .bPower{ background:#ffc24a } .bSp{ background:#fff }
  .bSp[disabled]{ background:#777; color:#333; cursor:not-allowed }
</style>
</head>
<body>
<div id="wrap">
  <div id="hudTop">
    <div class="pill">MOB 3on3（512）</div>
    <div class="pill">時間: <span id="time">120</span>s</div>
    <div class="pill">必殺: <span id="sp">2</span></div>
    <div class="pill">操作：敵タップ→メニュー→自分頭上ゲージ／自陣シングルタップ＝操作切替／自陣ダブルタップ＝パス</div>
  </div>

  <div id="stage">
    <canvas id="cv" width="512" height="512"></canvas>
    <!-- 敵頭上メニュー（DOM重ね） -->
    <div id="headMenu" class="btnRow" style="display:none">
      <button class="bTech"  data-choice="tech">テク</button>
      <button class="bPower" data-choice="power">パワ</button>
      <button class="bSp"    data-choice="sp">必殺</button>
    </div>
  </div>

  <div id="hudBtm">
    <div class="joy" id="joy">
      <div class="base"></div><div class="ring"></div><div class="knob" id="knob"></div>
    </div>
    <div class="actions">
      <div class="ab" id="btnCatch"><div>CATCH</div><small>緩和</small></div>
      <div class="ab" id="btnCancel"><div>キャンセル</div><small>解除</small></div>
    </div>
  </div>
</div>
<div id="toast"></div>

<script>
(() => {
  // ===== Canvas =====
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d'); ctx.imageSmoothingEnabled = false;

  // ===== HUD refs =====
  const timeEl = document.getElementById('time');
  const spEl   = document.getElementById('sp');
  const toastEl  = document.getElementById('toast');

  // ===== DOM menu =====
  const headMenu = document.getElementById('headMenu');
  const btnTech  = headMenu.querySelector('[data-choice="tech"]');
  const btnPower = headMenu.querySelector('[data-choice="power"]');
  const btnSp    = headMenu.querySelector('[data-choice="sp"]');

  // ===== Images =====
  const imgBG   = new Image(); imgBG.src   = 'DMH.png';
  const imgBall = new Image(); imgBall.src = 'ball.png';
  const imgChar = new Image(); imgChar.src = 'DMY1.png';

  // ===== Consts =====
  const W=512,H=512, CX=256, TOP=80, BOT=480, LB=32, RB=480; // 四方ネオン内側が壁
  const SEPARATION_MIN_D = 32;
  const SEPARATION_FORCE = 0.08;
  const PICKUP_RADIUS    = 40;     // 少し広げる
  const PICKUP_DELAY_MS  = 20;     // 早めに
  const AI_THROW_TIMEOUT = 1200;

  const coeff = {
    techSpeed: 7.2, powerSpeed: 10.6, specialSpeed: 12.0,
    techCost: 11, powerCost: 23,
    catchBaseMs: 200,                 // 基本の受付時間（↑緩和）
    catchDist: 96,                    // 距離（↑緩和）
    recoverPerSec: 3,
    knockTech:[8,14], knockPower:[18,26], knockSpcl:[28,40],
    gaugeTime: 680,
    passSpeed: 7.0,                   // パス速度
    passAutoCatchDist: 48,            // 受け手オートキャッチ距離
    passAutoCatchTime: 280            // 受け手オートキャッチ時間窓
  };

  // ===== Utils =====
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const rand=(a,b)=>a+Math.random()*(b-a);
  const now=()=>performance.now();
  const pingpong=(t)=>{ t%=2; return t<1?t:2-t; };
  const dist=(ax,ay,bx,by)=>Math.hypot(ax-bx, ay-by);

  function showToast(s){
    toastEl.textContent=s;
    toastEl.style.opacity=1;
    clearTimeout(showToast._t);
    showToast._t=setTimeout(()=>toastEl.style.opacity=0,1200);
  }

  // ===== Entities =====
  class Player{
    constructor(side,x,y,isHuman=false){
      this.side=side; this.x=x; this.y=y; this.w=32; this.h=32; this.isHuman=isHuman;
      this.stats={Power:62,Tech:58,Speed:82,Stamina:70,Catch:60,HP:112,Focus:60,Stability:50};
      this.speed = 2.2 + this.stats.Speed*0.013;
      this.maxHP=this.stats.HP; this.hp=this.maxHP;
      this.staminaMax=100+this.stats.Stamina*0.5;
      this.stamina=this.staminaMax; this.staRegen=coeff.recoverPerSec+this.stats.Stamina*0.03;
      this.dead=false; this.fade=1; this.hurt=0; this.cool=0;
      this.specialLeft=2; this.aiNext=now()+rand(100,180);
      this.vx=0; this.vy=0;
      this.intent='idle'; // 'chase'|'support'|'mark' etc.
    }
    rect(){ return {x:this.x-16,y:this.y-28,w:this.w,h:this.h}; }
  }
  class Ball{
    constructor(){
      this.x=CX; this.y=(TOP+BOT)/2; this.vx=0; this.vy=0;
      this.owner=null;          // owned中のみ所有者
      this.throwerSide=null;    // air中：投げた陣営
      this.state='free';        // 'free' | 'owned' | 'air'
      this.lastThrow=0; this.lastChoice='power';
      this.reserveId=null;
      this.passTarget=null;     // パスの受け手（Player）
      this.passStart=0;
    }
  }

  // Teams
  const L=[new Player('L', LB+84, 200, true),
           new Player('L', LB+60, 150, false),
           new Player('L', LB+60, 300, false)];
  const R=[new Player('R', RB-84, 200, false),
           new Player('R', RB-60, 150, false),
           new Player('R', RB-60, 300, false)];
  const ALL=[...L,...R]; let human=L[0]; const ball=new Ball();

  // ===== State =====
  let last=now(), paused=false, timeLeft=120000, extendTime=30000;
  let selectedEnemy=null;
  let gauge=null;   // {who,target,choice,t0,done,tap}
  let aiGauge=null; // {who,t0,choice,timeoutAt}
  let lastTapTime=0, lastTapPlayer=null;

  // ===== iOS scroll prevent on canvas =====
  cv.addEventListener('touchstart', e=>{ e.preventDefault(); }, {passive:false});
  cv.addEventListener('touchmove',  e=>{ e.preventDefault(); }, {passive:false});
  cv.addEventListener('touchend',   e=>{ e.preventDefault(); }, {passive:false});

  // ===== Virtual Joystick =====
  const joy = document.getElementById('joy');
  const knob= document.getElementById('knob');
  let joyActive=false, joyVec={x:0,y:0};
  const joyRect=()=>joy.getBoundingClientRect();
  function joySet(e,on){
    if(e){ e.preventDefault(); e.stopPropagation(); }
    joyActive=on;
    if(!on){ joyVec={x:0,y:0}; knob.style.left='50%'; knob.style.top='50%'; return; }
    joyMove(e);
  }
  function joyMove(e){
    if(e){ e.preventDefault(); e.stopPropagation(); }
    const r=joyRect(), cx=r.left+r.width/2, cy=r.top+r.height/2;
    const t = (e.touches? e.touches[0]: e);
    const tx=t.clientX, ty=t.clientY;
    let dx=tx-cx, dy=ty-cy; const len=Math.hypot(dx,dy)||1, maxR=44;
    if(len>maxR){ dx=dx/len*maxR; dy=dy/len*maxR; }
    knob.style.left=(50 + dx/(r.width/2)*50)+'%'; knob.style.top=(50 + dy/(r.height/2)*50)+'%';
    joyVec={x:dx/maxR, y:dy/maxR};
  }
  joy.addEventListener('mousedown', e=>joySet(e,true), {passive:false});
  window.addEventListener('mouseup', e=>joySet(e,false), {passive:false});
  window.addEventListener('mousemove', e=>{ if(joyActive) joyMove(e); }, {passive:false});
  joy.addEventListener('touchstart', e=>joySet(e,true), {passive:false});
  joy.addEventListener('touchend',   e=>joySet(e,false), {passive:false});
  joy.addEventListener('touchcancel',e=>joySet(e,false), {passive:false});
  joy.addEventListener('touchmove',  e=>{ if(joyActive) joyMove(e); }, {passive:false});

  // ===== Buttons =====
  document.getElementById('btnCancel').onclick=()=>{ closeMenu(); selectedEnemy=null; gauge=null; };
  document.getElementById('btnCatch').onclick=()=>{
    // free回収 or 空中キャッチ
    if(ball.state==='free' && dist(human.x,human.y,ball.x,ball.y) < PICKUP_RADIUS+10){ pickupBall(human); return; }
    attemptManualCatch(human);
  };

  // ===== Menu events =====
  const headMenu = document.getElementById('headMenu');
  const btnTech  = headMenu.querySelector('[data-choice="tech"]');
  const btnPower = headMenu.querySelector('[data-choice="power"]');
  const btnSp    = headMenu.querySelector('[data-choice="sp"]');
  btnTech.onclick = ()=>menuChoice('tech');
  btnPower.onclick= ()=>menuChoice('power');
  btnSp.onclick   = ()=>menuChoice('sp');

  function menuChoice(ch){
    if(!selectedEnemy) return;
    if(ch==='sp' && human.specialLeft<=0){ showToast('必殺なし'); return; }
    startGauge(human, selectedEnemy, ch);
    closeMenu();
  }

  // ===== Canvas taps =====
  cv.addEventListener('pointerdown',(e)=>{
    const r=cv.getBoundingClientRect();
    const x=(e.clientX-r.left)/(r.width/cv.width);
    const y=(e.clientY-r.top)/(r.height/cv.height);

    // まず自陣タップ：シングル/ダブル処理
    const ally = pickAt(x,y, L);
    if(ally){
      const t=now();
      if(lastTapPlayer===ally && (t-lastTapTime)<300){
        // ダブルタップ → パス
        lastTapTime=0; lastTapPlayer=null;
        tryPassTo(ally);
        return;
      }else{
        // シングル → 操作切替
        setHuman(ally);
        lastTapTime=t; lastTapPlayer=ally;
        return;
      }
    }

    // ゲージ停止（往復）
    if(gauge && !gauge.done){ gauge.tap=now(); gauge.done=true; return; }

    // 敵選択→頭上メニュー
    const hit = pickAt(x,y,R);
    if(hit){ selectedEnemy=hit; openMenuAbove(hit); return; }

    // 空白タップ
    closeMenu(); selectedEnemy=null;
  });

  // ===== Helpers =====
  function setHuman(p){
    for(const q of L) q.isHuman=false;
    p.isHuman=true; human=p;
    showToast('操作キャラ変更');
  }
  function pickAt(x,y,list){
    for(const p of list){
      if(p.dead) continue;
      const r=p.rect(); const ex=8,ey=8;
      if(x>=r.x-ex && x<=r.x+r.w+ex && y>=r.y-ey && y<=r.y+r.h+ey) return p;
    }
    return null;
  }
  function openMenuAbove(enemy){
    const stage = document.getElementById('stage').getBoundingClientRect();
    const rect=cv.getBoundingClientRect();
    headMenu.style.display='flex';
    const ex = (enemy.x/cv.width) * rect.width + rect.left;
    const ey = ((enemy.rect().y-10)/cv.height) * rect.height + rect.top;
    headMenu.style.left = (ex - stage.left - headMenu.offsetWidth/2) + 'px';
    headMenu.style.top  = (ey - stage.top) + 'px';
    btnSp.disabled = human.specialLeft<=0;
  }
  function closeMenu(){ headMenu.style.display='none'; }

  // ===== Gauge =====
  function startGauge(who,target,choice){
    if(choice==='sp'){ who.specialLeft=Math.max(0, who.specialLeft-1); if(who===human) spEl.textContent=human.specialLeft; }
    if(choice==='power' && who.stamina<coeff.powerCost*0.8) choice='tech';
    gauge={who,target,choice,t0:now(),done:false,tap:0};
  }
  function finishGauge(g){
    const t=(g.tap - g.t0)/coeff.gaugeTime; const perf = clamp(pingpong(t),0,1);
    throwBall(g.who, g.target, g.choice, perf, false);
    gauge=null;
  }

  // ===== Throw / Pass =====
  function throwBall(who,target,choice,perf,isPass){
    if(!isPass){
      if(choice==='power') who.stamina -= coeff.powerCost*(1.0 - perf*0.3);
      if(choice==='tech')  who.stamina -= coeff.techCost*(1.0 - perf*0.5);
      who.stamina=clamp(who.stamina,0,who.staminaMax);
    }
    // 速度
    let spd;
    if(isPass){
      spd = coeff.passSpeed + perf*1.2;
    }else{
      spd = (choice==='power') ? (8.5 + perf*(coeff.powerSpeed-8.5))
           : (choice==='tech')  ? (5.8 + perf*(coeff.techSpeed-5.8))
           :                      (10.2+ perf*(coeff.specialSpeed-10.2));
    }
    // 方向
    const dx=target.x-who.x, dy=target.y-who.y, ang=Math.atan2(dy,dx);
    ball.x=who.x + Math.cos(ang)*18; ball.y=who.y + Math.sin(ang)*12;
    ball.vx=Math.cos(ang)*spd; ball.vy=Math.sin(ang)*(spd*0.55);
    ball.owner=null;
    ball.throwerSide=who.side;
    ball.state='air';
    ball.lastThrow=now();
    ball.lastChoice=isPass? 'tech' : (choice||'tech');
    ball.reserveId=null;
    ball.passTarget = isPass? target : null;
    ball.passStart = isPass? now() : 0;
    who.cool=140;
  }

  function tryPassTo(targetAlly){
    // パス条件：自分がボール所持中 & 生きてる & 同陣営
    if(ball.state==='owned' && ball.owner && ball.owner.side==='L' && ball.owner===human){
      if(targetAlly.dead) return;
      throwBall(human, targetAlly, 'tech', 0.8, true);
      showToast('パス！');
    }else{
      // 所持してない場合はただの操作切替（すでに実施済み）
    }
  }

  // ===== Catch / Pickup =====
  function attemptManualCatch(p){
    if(ball.state!=='air') return;
    const ok = canCatch(p,true);
    if(ok) pickupBall(p,true);
    else p.hurt=90;
  }
  function canCatch(p,pressed=false){
    if(p.dead) return false;
    if(ball.state!=='air') return false;
    const towardLeft = ball.vx<0;
    if(p.side==='L' && !towardLeft) return false;
    if(p.side==='R' && towardLeft) return false;
    const d = dist(p.x,p.y, ball.x,ball.y);
    if(d > coeff.catchDist) return false;

    // タイミング窓（速度が遅いほど緩く）
    const elapsed = now()-ball.lastThrow;
    const speed = Math.hypot(ball.vx,ball.vy);
    const bonus = (pressed? 80:0) + (40 + (12 - Math.min(12, speed))*18); // 遅いと+大
    const center = 520; // 目安
    return Math.abs(elapsed - center) < (coeff.catchBaseMs + bonus);
  }
  function pickupBall(p,fromAir=false){
    ball.owner=p; ball.state='owned'; ball.vx=ball.vy=0; ball.passTarget=null;
    if(fromAir){ p.stamina = clamp(p.stamina+12,0,p.staminaMax); showToast('キャッチ！'); }
    ball.reserveId=null;
  }

  // ===== Damage / Knockback =====
  function onHit(def,choice,atk){
    let dmg=(choice==='power')?rand(26,34):(choice==='tech')?rand(18,24):rand(40,55);
    dmg *= (1 + (atk.stats?.Power??60)*0.004);
    let kb=(choice==='power')?rand(...coeff.knockPower):(choice==='tech')?rand(...coeff.knockTech):rand(...coeff.knockSpcl);
    kb *= (1 - (def.stats?.Stability??50)*0.008); kb=clamp(kb,4,42);
    def.hp -= Math.round(dmg); def.hurt=140;
    def.vx += (atk.x<def.x?1:-1) * kb*0.09; def.vy += rand(-0.4,0.4);

    // ヒット → ボールはfree化して減速・反発抑制
    ball.state='free'; ball.owner=null; ball.passTarget=null;
    ball.vx*=0.7; ball.vy*=0.5;
    clampBall('free');

    if(def.hp<=0){ def.hp=0; def.dead=true; def.fade=1; }
  }

  // ===== Bounds（プレイヤー/ボール） =====
  function clampSide(p){
    if(p.side==='L') p.x=clamp(p.x,LB+16,CX-16); else p.x=clamp(p.x,CX+16,RB-16);
    p.y=clamp(p.y,TOP+16,BOT-8);
  }
  function clampBall(mode){
    if(mode==='owned'){
      ball.x = clamp(ball.x, LB+8, RB-8);
      ball.y = clamp(ball.y, TOP+8, BOT-8);
      return;
    }
    const rx = (mode==='air')? -0.6 : -0.4;
    const ry = (mode==='air')? -0.6 : -0.4;
    if(ball.x<LB){ ball.x=LB; ball.vx*=rx; }
    if(ball.x>RB){ ball.x=RB; ball.vx*=rx; }
    if(ball.y<TOP){ ball.y=TOP; ball.vy*=ry; }
    if(ball.y>BOT){ ball.y=BOT; ball.vy*=ry; }
  }

  // ===== Separation（速度ベース斥力） =====
  function applySeparation(team){
    for(let i=0;i<team.length;i++){
      for(let j=i+1;j<team.length;j++){
        const a=team[i], b=team[j];
        if(a.dead||b.dead) continue;
        const dx=a.x-b.x, dy=a.y-b.y, d=Math.hypot(dx,dy);
        if(d>0 && d<SEPARATION_MIN_D){
          const f=(SEPARATION_MIN_D-d)/SEPARATION_MIN_D * SEPARATION_FORCE;
          const nx=dx/d, ny=dy/d;
          a.vx += nx*f; a.vy += ny*f;
          b.vx -= nx*f; b.vy -= ny*f;
        }
      }
    }
  }

  // ===== AI（自由移動寄り） =====
  function cpuThink(p){
    if(p.dead) return;

    // 所持時：投げる or パス
    if(ball.state==='owned' && ball.owner===p && p.cool<=0){
      if(!aiGauge){
        const delay = rand(400,900);
        const passChance = 0.25 + (Math.random()*0.15); // 25〜40%でパス検討
        const passTo = pickPassTarget(p);
        if(passTo && Math.random()<passChance){
          // パス用の短いゲージ的ディレイ→自動発射
          aiGauge = { who:p, t0: now()+delay, choice:'tech', timeoutAt: now()+delay+AI_THROW_TIMEOUT, passTo };
        }else{
          aiGauge = { who:p, t0: now()+delay, choice:(p.stamina>24 && Math.random()<0.6)?'power':'tech',
                      timeoutAt: now()+delay+AI_THROW_TIMEOUT, passTo:null };
        }
      }
      return;
    }

    // free：段階的に人員投入（遠いボール放置対策）
    if(ball.state==='free'){
      const tFree = now() - ball.lastThrow;
      const quota = (tFree<600)? 1 : (tFree<1200)? 2 : 3; // 最大3人まで寄る
      // 自チームの並びで近い順に quota 人は“chase”
      const myTeam = (p.side==='L')? L : R;
      const chasers = myTeam
        .filter(q=>!q.dead)
        .sort((a,b)=>dist(a.x,a.y,ball.x,ball.y)-dist(b.x,b.y,ball.x,ball.y))
        .slice(0, quota);
      if(chasers.includes(p)){
        // 直行
        moveToward(p, ball.x, ball.y, 0.95, true);
        p.intent='chase';
      }else{
        // セーフポジ（拾いこぼしを拾う三角位置）
        const tx = (p.side==='L')? clamp(ball.x-24, LB+40, CX-24) : clamp(ball.x+24, CX+24, RB-40);
        const ty = clamp(ball.y + ((p===myTeam[1])?-36:36), TOP+24, BOT-24);
        moveToward(p, tx, ty, 0.75, false);
        p.intent='support';
      }
      return;
    }

    // 相手所持：マーク（進路に入る簡易ヒューリスティック）
    if(ball.state==='owned' && ball.owner && ball.owner.side !== p.side){
      const owner = ball.owner;
      const tx = (p.side==='L')? clamp(owner.x-30, LB+32, CX-32) : clamp(owner.x+30, CX+32, RB-32);
      const ty = clamp(owner.y + (p===((p.side==='L')?L[1]:R[1])?-28:28), TOP+20, BOT-20);
      moveToward(p, tx, ty, 0.8, false);
      p.intent='mark';
      return;
    }

    // 味方所持（自分は非所持）：前の空きへ広がって受け角度を作る
    if(ball.state==='owned' && ball.owner && ball.owner.side === p.side && ball.owner!==p){
      const tx = (p.side==='L')? clamp(CX-60 + (p===((p.side==='L')?L[1]:R[1])? -10:10), LB+40, CX-40)
                               : clamp(CX+60 + (p===((p.side==='L')?L[1]:R[1])? 10:-10), CX+40, RB-40);
      const ty = clamp(ball.owner.y + (p===((p.side==='L')?L[1]:R[1])?-42:42), TOP+24, BOT-24);
      moveToward(p, tx, ty, 0.8, false);
      p.intent='support';
      return;
    }

    // それ以外：緩く中央付近へ
    const midx=(p.side==='L')? CX-80 : CX+80, midy=clamp(p.y,150,300);
    moveToward(p, midx, midy, 0.7, false);
    p.intent='idle';
  }

  function pickPassTarget(owner){
    const mates = (owner.side==='L'? L : R).filter(m=>m!==owner && !m.dead);
    if(!mates.length) return null;
    // “角度”と“距離”でスコア
    let best=null, bestScore=-1e9;
    for(const m of mates){
      const d=dist(owner.x,owner.y,m.x,m.y);
      const goodDist = (d>40 && d<200)? 1 : (d<=40? 0.5 : 0.7);
      // 敵からの距離（インターセプトされにくさ）
      const foes = (owner.side==='L'? R : L).filter(f=>!f.dead);
      let minF=1e9; for(const f of foes){ const df=dist(m.x,m.y,f.x,f.y); if(df<minF) minF=df; }
      const safe = Math.min(1, minF/140);
      const score = goodDist*0.6 + safe*0.4;
      if(score>bestScore){ bestScore=score; best=m; }
    }
    return best;
  }

  // ===== Step =====
  function step(ms){
    if(paused) return;

    // 時間
    timeLeft -= ms; if(timeLeft<=0){
      const La=L.filter(p=>!p.dead).length, Ra=R.filter(p=>!p.dead).length;
      if(La===Ra && extendTime>0){ timeLeft+=extendTime; extendTime=0; } else return endMatch(La>Ra?'勝ち':(La<Ra?'負け':'引き分け'));
    }
    timeEl.textContent = Math.ceil(timeLeft/1000);

    // Human move
    if(!human.dead){
      const len=Math.hypot(joyVec.x,joyVec.y)||1;
      const vx=(joyVec.x/len)*human.speed, vy=(joyVec.y/len)*human.speed;
      human.vx = human.vx*0.6 + vx*0.4;
      human.vy = human.vy*0.6 + vy*0.4;
    }

    // CPU think
    const tnow=now();
    for(const p of ALL){
      if(p.dead) continue;
      if(!p.isHuman && p.aiNext<=tnow){ cpuThink(p); p.aiNext=tnow+rand(100,180); }
    }

    // Separation
    applySeparation(L); applySeparation(R);

    // integrate velocity
    for(const p of ALL){
      if(p.dead){ p.fade=Math.max(0,p.fade-ms*0.002); continue; }
      p.stamina = clamp(p.stamina + (p===ball.owner? (coeff.recoverPerSec*0.6) : coeff.recoverPerSec)*(ms/1000), 0, p.staminaMax);
      if(p.hurt>0) p.hurt-=ms;
      if(p.cool>0) p.cool-=ms;
      p.x += p.vx; p.y += p.vy;
      p.vx*=0.9; p.vy*=0.9;
      clampSide(p);
    }

    // Human gauge
    if(gauge && gauge.done) finishGauge(gauge);

    // CPU gauge（投げorパス）
    if(aiGauge){
      const ag = aiGauge;
      if(!ag.who || ag.who.dead || ball.state!=='owned' || ball.owner!==ag.who){ aiGauge=null; }
      else if(tnow >= ag.t0){
        const elapsed = tnow - ag.t0;
        if(elapsed >= coeff.gaugeTime*0.65 || tnow >= ag.timeoutAt){
          if(ag.passTo && !ag.passTo.dead){
            throwBall(ag.who, ag.passTo, 'tech', 0.8, true);
          }else{
            const enemies=(ag.who.side==='L'?R:L).filter(q=>!q.dead);
            if(enemies.length){
              enemies.sort((a,b)=>dist(ag.who.x,ag.who.y,a.x,a.y)-dist(ag.who.x,ag.who.y,b.x,b.y));
              throwBall(ag.who, enemies[0], ag.choice, 0.82, false);
            }
          }
          aiGauge=null;
        }
      }
    }

    // Ball physics
    if(ball.state==='air'){
      ball.x+=ball.vx; ball.y+=ball.vy; ball.vy*=0.995;
      clampBall('air');

      // パスの受け手が近ければオートキャッチ
      if(ball.passTarget && !ball.passTarget.dead){
        const tPass = now()-ball.passStart;
        if(tPass < coeff.passAutoCatchTime && dist(ball.passTarget.x,ball.passTarget.y,ball.x,ball.y) < coeff.passAutoCatchDist){
          pickupBall(ball.passTarget,true);
        }
      }

      // 人が手動キャッチできるかどうかは attemptManualCatch / canCatch に委ね

      // ヒット（投げ付け）
      const enemies=(ball.throwerSide==='L')? R : L;
      for(const e of enemies){
        if(e.dead) continue; const r=e.rect();
        if(ball.x>=r.x && ball.x<=r.x+r.w && ball.y>=r.y && ball.y<=r.y+r.h){
          onHit(e, ball.lastChoice||'tech', {x:(ball.throwerSide==='L'? LB:RB), y:e.y, stats:{Power:60}});
          ball.lastThrow=tnow;
          break;
        }
      }

      // 長い空中 or 極端に遅い→free
      const speed=Math.hypot(ball.vx,ball.vy);
      if(speed<0.9 || (tnow - ball.lastThrow) > 1400){
        ball.state='free'; ball.lastThrow=tnow; ball.passTarget=null;
      }

    }else if(ball.state==='free'){
      ball.vx*=0.985; ball.vy*=0.985; ball.x+=ball.vx; ball.y+=ball.vy;
      clampBall('free');
      // “誰でも拾える”：最寄りが半径内なら即回収
      if(tnow-ball.lastThrow>PICKUP_DELAY_MS){
        let picker=null, bd=1e9;
        for(const p of ALL){ if(p.dead) continue; const d=dist(p.x,p.y,ball.x,ball.y); if(d<bd){bd=d; picker=p;} }
        if(picker && bd<PICKUP_RADIUS){ pickupBall(picker); }
      }

    }else if(ball.state==='owned'){
      if(ball.owner && !ball.owner.dead){
        const sgn=(ball.owner.side==='L')?1:-1;
        ball.x=ball.owner.x+10*sgn; ball.y=ball.owner.y-6;
        clampBall('owned');
      }else{ ball.state='free'; ball.owner=null; }
    }

    // KO
    const La=L.filter(p=>!p.dead).length, Ra=R.filter(p=>!p.dead).length;
    if(La===0 || Ra===0) endMatch(La>0?'勝ち':'負け');
  }

  function endMatch(result){ paused=true; setTimeout(()=>alert(`試合終了：${result}\n（リロードで再戦）`),10); }

  // ===== Draw =====
  function draw(){
    if(imgBG.complete && imgBG.naturalWidth>0) ctx.drawImage(imgBG,0,0,cv.width,cv.height);
    else { ctx.fillStyle='#063'; ctx.fillRect(0,0,cv.width,cv.height); }
    ctx.fillStyle="#ffffff55"; ctx.fillRect(CX-1,TOP,2,BOT-TOP);

    const list=ALL.slice().sort((a,b)=>a.y-b.y);
    for(const p of list){
      const r=p.rect();
      if(!p.dead){
        const w=28,h=4,hpw=Math.round(w*(p.hp/p.maxHP));
        ctx.fillStyle="#0008"; ctx.fillRect(p.x-w/2, r.y-7, w, h);
        ctx.fillStyle="#0f0"; ctx.fillRect(p.x-w/2, r.y-7, Math.max(0,hpw), h);
      }
      ctx.save();
      if(p.hurt>0){ ctx.globalAlpha=0.6+0.4*Math.sin((p.hurt/140)*24); }
      const flip=(p.side==='R')?-1:1;
      if(imgChar.complete && imgChar.naturalWidth>0){
        ctx.translate(p.x, r.y); ctx.scale(flip,1); ctx.drawImage(imgChar, -16, 0, 32,32);
      }else{ ctx.fillStyle='#ffd60a'; ctx.fillRect(r.x,r.y,32,32); ctx.strokeStyle="#000"; ctx.strokeRect(r.x+0.5,r.y+0.5,31,31); }
      ctx.restore();

      // 操作中アイコン
      if(p===human && !p.dead){
        ctx.fillStyle="#000a"; ctx.fillRect(p.x-10, p.y-58, 20, 12);
        ctx.fillStyle="#fff"; ctx.font="10px monospace"; ctx.textAlign="center"; ctx.fillText("YOU", p.x, p.y-48);
      }
    }

    if(imgBall.complete && imgBall.naturalWidth>0) ctx.drawImage(imgBall, Math.round(ball.x-8), Math.round(ball.y-8), 16,16);
    else { ctx.fillStyle="#f90"; ctx.fillRect(ball.x-4,ball.y-4,8,8); }

    if(gauge){ drawGaugeAbove(gauge.who, gauge.choice, (now()-gauge.t0)/coeff.gaugeTime); }

    if(aiGauge && aiGauge.who && ball.state==='owned' && ball.owner===aiGauge.who){
      const tRaw = (now() - aiGauge.t0)/coeff.gaugeTime;
      drawGaugeAbove(aiGauge.who, aiGauge.choice, Math.max(0, tRaw));
    }
  }

  function drawGaugeAbove(who, choice, tRaw){
    const t=pingpong(tRaw); const w=150,h=12;
    const x=clamp(who.x-w/2, 20, W-w-20), y=who.y-46;
    ctx.fillStyle="#000a"; ctx.fillRect(x-2,y-2,w+4,h+4);
    ctx.fillStyle="#222"; ctx.fillRect(x,y,w,h);
    ctx.fillStyle="#0f0"; ctx.fillRect(x+2,y+2,Math.floor(w*0.5)-2, h-4);
    ctx.fillStyle="#ff0"; ctx.fillRect(x+Math.floor(w*0.5),y+2,Math.floor(w*0.3), h-4);
    ctx.fillStyle="#f30"; ctx.fillRect(x+Math.floor(w*0.8),y+2,Math.floor(w*0.2)-2, h-4);
    const cur=Math.floor((w-6)*t); ctx.fillStyle="#fff"; ctx.fillRect(x+3+cur, y+1, 4, h-2);
    ctx.fillStyle="#fff"; ctx.font="10px monospace"; ctx.textAlign="center";
    const lab=choice==='power'?'パワー':(choice==='tech'?'テク':'必殺'); ctx.fillText(lab, x+w/2, y-6);
  }

  // ===== Loop =====
  function loop(){
    const t=now(); const ms=t-last; last=t;
    if(!paused){ step(ms); draw(); }
    requestAnimationFrame(loop);
  }
  loop();

  // ===== Window =====
  window.addEventListener('keydown',e=>{ if(e.key==='Escape'){ closeMenu(); selectedEnemy=null; } });

})();
</script>
</body>
</html>
